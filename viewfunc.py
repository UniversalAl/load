'''
helper functions for vapoursynth view2.py previewer but could be used outside of this package
constructed to work with API3 or API4 
'''

import os
import sys
import vapoursynth as vs
from vapoursynth import core
import json
import functools
import tempfile
import platform
import logging
import io
from typing import Optional

try:
    import numpy as np
    IS_NUMPY=True
except ImportError:
    IS_NUMPY=False

try:
    import cv2
    IS_OPENCV=True
except ImportError:
    IS_OPENCV=False
    
def setup_logger(name,
                 formatter=logging.Formatter('[%(module)s.%(funcName)s] %(message)s'),
                 level=logging.DEBUG):
    logger = logging.getLogger(name)
    logger.setLevel(level)
    log_string = io.StringIO()
    ch = logging.StreamHandler(log_string)
    ch.setLevel(level)
    ch.setFormatter(formatter)
    logger.addHandler(ch)
    return logger, log_string

logger, log_string = setup_logger(name=__name__)

def clear_logs():
    log_string.seek(0)
    log_string.truncate(0)
    
BLANK = core.std.BlankClip(width=640, height=360, color =(16,16,16), length=1)

def is_API4():
    try:
        is_api4 = vs.__api_version__.api_major >= 4
    except AttributeError:
        is_api4 = False
    return is_api4

isAPI4 = is_API4()
    
TRANSFER =     {
##                0:'reserved',
                1:'709',
                2:'unspec',
##                3:'reserved',
                4:'470m',
                5:'470bg',
                6:'601',
                7:'240m',
                8:'linear',
                9:'log100',
                10:'log316',
                11:'xvycc',
                13:'srgb',
                14:'2020_10', #use for '2020'
                15:'2020_12',
                16:'st2084',
                18:'std-b67'
                }                             

MATRIX =      {
                0:'rgb',
                1:'709',
                2:'unspec',
##                3:'reserved',
                4:'fcc',
                5:'470bg',
                6:'170m',
                7:'240m',
                8:'ycgco',
                9:'2020ncl',
               10:'2020cl' ,
               12:'chromancl',
               13:'chromacl',
               14:'ictcp'
              }   

MATRIX_USABLE = {
                  1 : '709'   ,
                  4 : 'fcc'   ,
                  5 : '470bg' ,    #use for '601'
                  6 : '170m'  ,
                  7 : '240m'  ,
                  8 : 'ycgco' ,
                  9 : '2020ncl'  , #use for '2020'
                 10 : '2020cl'   ,
                 12 : 'chromancl',
                 13 : 'chromacl ',
                 14 : 'ictcp'
               }

PRIMARIES =   {
                1 : '709'    ,
                2 : 'unspec' ,
                4 : '470m'   ,
                5 : '470bg'  ,
                6 : '170m'   ,
                7 : '240m'   ,
                8 : 'film'   ,
                9 : '2020'   ,
               10 : 'st428'  , #use for 'xyz'
               11 : 'st431-2', #use for 'dci-p3'
               12 : 'st432-1', #use for 'display-p3'
               22 : 'jedec-p22'
                }


INT_PROPS = {                   #int values
            '_ChromaLocation':  {0:'left', 1:'center', 2:'top_left', 3:'top', 4:'bottom_left', 5:'bottom'},
            '_ColorRange':      {0:'full', 1:'limited'},
            '_Matrix':           MATRIX    ,
            '_Primaries':        PRIMARIES ,
            '_Transfer':         TRANSFER  ,
            '_FieldBased':      {0:'progressive', 1:'bottom field first', 2:'top field first'},
            '_DurationNum':     {},
            '_DurationDen':     {},
            '_Combed':          {},    #or bool
            '_Field':           {0:'from bottom field, if frame was generated by SeparateFields',
                                  1:'from top field, if frame was generated by SeparateFields'},
            '_SARNum':          {},
            '_SARDen':          {},
            '_SceneChangeNext': {0:'nope',1:'LAST FRAME of the current scene'}, #or bool
            '_SceneChangePrev': {0:'nope',1:'FRAME STARTS a new scene'},        #or bool
            } 
PROPS = INT_PROPS.copy()
PROPS.update({    
            '_AbsoluteTime':    {}, #float
            '_PictType':        {}, #str
            '_Alpha':           {}  #vs.VideoFrame
              })

CPU_TYPE =       ["auto","auto64","mmx","sse","sse2","sse3","ssse3","sse41","sse42","avx","f16c",
                  "avx2","avx512f","avx512skx","avx512clx","avx512snc"]
DITHER_TYPE =    ['ordered', 'random', 'error_diffusion']
KERNELS =        ["Point","Bicubic","Spline16","Spline36","Spline64","Lanczos"]
CHROMA_KERNELS = ["point","bicubic","spline16","spline36","spline64","lanczos"]


def write_props(clip, **kwargs):
    '''
    kwargs are: prop1=value1, prop2=value2, ... this will work for for API3 and API4
    Keys are strings only, valueas can be: int, str, lists or dictionaries.
    As for dictionaries, whatever json allows. Not wanting to go into annotations nightmare for it,
    if it is a dictionary passed as a value, it can be whatever json module can decode to bytes.
    As for lists and tuples,  values can be int, float, str, same type for a particular list.
    
    Note: If complicated values, use a dictionary!  json module is used to write to bytes, and that is stored to a prop.
    Then it is read from bytes back to a dictionary by json again in read_prop(), so structure can be really complicated one.
    Example:
    clip = viewfunc.write_props(
        clip,
        _FieldBased  = 1,
        any_string   = 'dogs',
        data         = {'clip_name':'Kittens', 'litter_of':3, 'names': {'fluffy':'Anna','ginger':'Bob','mottled':'Jen'}},
        filters      = {'denoise':['core','fft3dfilter','FFT3DFilter',{'sigma':1.5}]},
        integer_list = [2, 6],
        string_list  = ['apples','oranges']
        )
    '''
    for prop, value in kwargs.items():
        if prop in INT_PROPS and not isinstance(value, int):
            raise ValueError(f'[viewfunc] prop "{prop}" needs to be an integer')
        if prop == '_Alpha' and not isinstance(value, vs.VideoFrame):
            raise ValueError(f'[viewfunc] prop "_Alpha" needs to be a vapoursynth.VideoFrame type') 
    
    if isAPI4:
        if vs.__version__.release_major <57: #R55, R56 are still stripping leading underscores from keys, so adding one more
            _kwargs = list(kwargs.items())
            kwargs.clear()
            for prop, value in _kwargs.items():
                if prop.startswith('_'):
                    prop = f'_{prop}'
                kwargs[prop] = value
        for prop, value in kwargs.items():
            if isinstance(value, dict):
                kwargs[prop] = json.dumps(value)
        return clip.std.SetFrameProps(**kwargs)
    
    else:
        #API3
        for prop, value in kwargs.items():
            if isinstance(value, dict):
                options = dict(prop=prop, data=json.dumps(value))
            elif isinstance(value, int):  options = dict(prop=prop, intval=value)
            else:                         options = dict(prop=prop, data=value)                
            clip = clip.std.SetFrameProp(**options)
        return clip  

    
def read_prop(f, prop):
    '''
    Can read int, str, lists or dictionaries from props for API3 and API4
    
    for example props were saved like this:
    --------------------------------------
    clip = viewfunc.write_props(
        clip,
        _FieldBased  = 1,
        any_string   = 'dogs',
        data         = {'clip_name':'Kittens', 'litter_of':3, 'names': {'fluffy':'Anna','ginger':'Bob','mottled':'Jen'}},
        filters      = {'denoise':['core','fft3dfilter','FFT3DFilter',{'sigma':1.5}]},
        integer_list = [2, 6],
        string_list  = ['apples','oranges']
        )
            
    then reading those props:
    ------------------------
    props_to_read = ['_FieldBased', 'any_string', 'data','filters', 'integer_list', 'string_list']
    for prop in props_to_read:
        print(viewfunc.read_prop(clip.get_frame(0), prop))
        
    we get correct python objects:
    ------------------------------
    1
    dogs
    {'clip_name': 'Kittens', 'litter_of': 3, 'names': {'fluffy': 'Anna', 'ginger': 'Bob', 'mottled': 'Jen'}}
    {'denoise':['core','fft3dfilter','FFT3DFilter',{'sigma':1.5}]}
    [2, 6]
    ['apples', 'oranges']
    '''
    if isinstance(f, vs.VideoNode):
        raise ValueError('value passed to read_prop() was a clip instead of a frame')
    if prop not in f.props:
        return None
    v = f.props[prop]
    if isinstance(v, bytes):
        try:
            data = json.loads(v)
        except  json.decoder.JSONDecodeError:
            data = v.decode()  
        return data
    elif isinstance(v, (tuple,list)):
        #API3 list reading
        items = []
        for item in v:
            try:
                item = item.decode()
                item = int(item)
            except AttributeError:
                item = 'cannot be decoded from bytes'
            except ValueError:
                #it is not an integer in API3, str gets passed
                pass
            finally:
                items.append(item)
        return items
    return v


def delete_prop(clip, prop):
    '''
    example:
    clip = viewfunc.delete_prop(clip, '_FieldBased')
    '''
    if isAPI4: return clip.std.SetFrameProps(prop=prop, delete=True)
    else:      return clip.std.SetFrameProp (prop=prop, delete=True)


def get_zimg_range(clip, range_input=None):
    '''Input is any range, int, str or None
    if None check props, if not default to "limited" for zimg conversion'''
    try:
        f = clip.get_frame(0)
    except vs.Error as e:
        raise ValueError(f'requesting frame for this VideoNode to get range failed: {clip}\n{e}')
    strings = ['limited', 'full']
    if range_input is None:
        if '_ColorRange' in f.props:
            range_in = {0:1,1:0}[f.props['_ColorRange']]
            range_ = (range_in, strings[range_in])
        else:
            range_ = (0, 'limited')
    elif range_input in [0,1]:
        range_ = (range_input, strings[range_input])
    elif range_input in strings:
        range_ = ({'limited':0, 'full':1}[range_input], range_input)
    else:
         raise ValueError('range value for a vs.VideoNode should be 0, 1, "limited" or "full"')
    return range_

def get_matrix(clip, matrix_input=None):
    '''
    Objective is to come up with matrix for rgb conversion and log it.
    Example:
    import viewfunc
    matrix_in, matrix_in_s = viewfunc.get_matrix(clip, matrix_input='470bg')
    print(matrix_in)
    >>>5
    
    if just wanting a string type and knowing int type, in our case int 5:
    print(viewfunc.MATRIX[5])
    >>>470bg
    '''
    if not isinstance(clip, vs.VideoNode) and clip.format.color_family != vs.YUV:
        raise ValueError("First argument in get_matrix needs to be a YUV clip")
    try:
        f = clip.get_frame(0)
    except vs.Error as e:
        raise ValueError('requesting frame for this VideoNode to get matrix failed: {clip}\n{e}')
                         
    matrix_in, matrix_in_s = None, None
    def matrix_from_props(clip):           
        logger.info('checking props: matrix_in=clip.get_frame(0).props["_Matrix"]')

        def default_matrix(clip):
            '''This is a poor guess, last resort, befor rgb conversion, if there is no other way to deduce matrix.'''  
            if   clip.width <= 1024 and clip.height <= 480:
                matrix_in = 6
            elif clip.width <= 1024 and clip.height <= 576:
                matrix_in = 5
            else:
                matrix_in = 1
            logger.info(f'defaulting, which could be wrong, to: matrix_in={matrix_in}')
            return matrix_in
        
        matrix_in = read_prop(clip.get_frame(0), '_Matrix')
        if matrix_in is None:
            logger.info('key "_Matrix" NOT FOUND')
            return default_matrix(clip)
        
        elif matrix_in not in MATRIX_USABLE.keys():
            logger.info('key "_Matrix" FOUND but is not usable')
            return default_matrix(clip)
        else:    
            return  f.props['_Matrix']

    if matrix_input is None:
        logger.info(f"input matrix value is None")
        matrix_input = matrix_from_props(clip)

    if isinstance(matrix_input, int):
        if not matrix_input in MATRIX_USABLE.keys():
            err =  f"[get_matrix] argument matrix: {matrix_input} is not usable for color conversion to rgb"
            err += f"Usable matrix values are: {MATRIX_USABLE.keys()}"
            raise ValueError(err)
        matrix_in = matrix_input
        matrix_in_s = MATRIX_USABLE[matrix_input]
        
    elif isinstance(matrix_input, str):
        if not matrix_input in MATRIX_USABLE.values():
            err =  f"[get_matrix] argument matrix: {matrix_input} is not usable for color conversion to rgb"
            err += f"Usable matrix values are: {MATRIX_USABLE.values()}"
            raise ValueError(err)
        matrix_in = next(k for k, v in MATRIX_USABLE.items() if v == matrix_input)
        matrix_in_s = matrix_input
    else:
        raise ValueError("[get_matrix] value for matrix needs to be integer, string or None(will be pulled from props or defaulted)")

    logger.info(f'input matrix passed: matrix_in_s="{matrix_in_s}", (matrix_in={matrix_in})')

    return matrix_in, matrix_in_s
      

def toRGB(kernel, clip, **zimg_kwargs):
    '''
    Input:   (kernel,  YUV clip,        **zimg_kwargs)
              <str>    <vs.VideoNode>   all available vs.core.resize.XYZ keyword arguments for RGB conversion,
                                        kwargs not needed for rgb conversion are ignored
    
    Returns  <vs.VideoNode>

    -> matrix and range input will be evaluated, could be None also in zimg_kwargs, then they will be pulled from props or defaulted to
    -> Always returns a clip , even if there is an error during conversion, clip is replaced with black rgb clip,
       and if numpy and opencv are installed, then there are two crossed red lines
    -> resizing is interlace aware if _FieldBased prop exists and it is 1 or 2
    -> vs.core.resize arguments can be just copy/pasted from vapoursynth script to arguments for toRGB, it takes them all
       where kernel must be obviously added as a first argument or use viewfunc.Resize() class
    -> It LOGs! It logs whatever it does! even if there is an error, it's is going to be logged, you can get log after conversion
    -> if there was an error it creates vapoursynth prop named 'isError' and value will be 1,
       if conversion went without error 'isError' will be 0

    Usage example:
    
    import viewfunc
    rgb = viewfunc.toRGB('Bicubic', clip, format=vs.RGB24, dither_type='error_diffusion)
    log = viewfunc.log_string.getvalue()
    if viewfunc.read_prop(rgb, 'isError')
       raise ValueError(f'rgb conversion failed!\n{log}')
    '''
    clear_logs()
    try:
        f = clip.get_frame(0)
    except vs.Error as e:
        raise ValueError('requesting frame for this VideoNode for rgb conversion failed: {clip}\n{e}')
    if isinstance(kernel, vs.VideoNode):
        raise ValueError('[toRGB] first argument must be kernel, not clip')
    if not isinstance(clip, vs.VideoNode):
        raise ValueError('[toRGB] second argument must be a clip')    
    kernels = ["POINT","BICUBIC","SPLINE16","SPLINE36","SPLINE64","LANCZOS"]
    if not (isinstance(kernel, str) and kernel.upper() in kernels):
        raise ValueError('[toRGB] kernel is not a valid value\n'
                         f'valid values: "Point","Bicubic","Spline16","Spline36","Spline64","Lanczos"')
    kernel = kernel[0].upper() + kernel[1:].lower()
    if not 'format' in zimg_kwargs:
        zimg_kwargs['format'] = vs.RGB24
    if not core.get_format(zimg_kwargs['format']).color_family == vs.RGB:
        raise ValueError('[toRGB] format must be RGB color family (even viewfunc.resize is implemented for rgb conversion only)')
    
    field_based = 0
    try:
        field_based = clip.get_frame(0).props['_FieldBased'] #0=progressive, 1=bottom field first, 2=top field first
    except KeyError:
        pass
    if field_based:
        #convert as interlaced
        logger.info(f'_FieldBased={field_based}, clip is flagged as interlaced: clip=clip.std.SeparateFields()')
        clip = clip.std.SeparateFields()
 
    def ERROR_OUT(clip, error):
        rgb = default_error_rgb_clip(clip.width, clip.height)
        logger.info(str(error))
        rgb = write_props(rgb, isError=1)
        return rgb
    
    if clip.format.color_family == vs.YUV or clip.format.name=='COMPATYUY2':
        if   'matrix_in' in zimg_kwargs:   matrix_input = zimg_kwargs.pop('matrix_in', None)
        elif 'matrix_in_s' in zimg_kwargs: matrix_input = zimg_kwargs.pop('matrix_in_s', None)
        else: matrix_input = None
        if   'range_in' in zimg_kwargs:   range_input = zimg_kwargs.pop('range_in', None)
        elif 'range_in_s' in zimg_kwargs: range_input = zimg_kwargs.pop('range_in_s', None)
        else: range_input = None        
        try:
            #matrix and range gets validated or defaulted if None
            matrix_in, matrix_in_s = get_matrix(clip, matrix_input)
            range_in, range_in_s   = get_zimg_range(clip, range_input)
        except ValueError as e:
            return ERROR_OUT(clip, e)
        else:    
            zimg_kwargs['matrix_in_s'] = matrix_in_s
            zimg_kwargs['range_in_s']  = range_in_s
    else:
        #RGB input
        for k in ['_Matrix','_Primaries','_Transfer']:
           clip = delete_prop(clip, k)

    #formatting conversion line for log
    l = []
    new_line=''
    if len(zimg_kwargs.keys())>2:
        new_line='\n'+' '*31
    for k,v in zimg_kwargs.items():
        if isinstance(v, vs.PresetFormat):
            v = 'vs.'+ str(zimg_kwargs['format']).split('.')[1]
        elif isinstance(v, str):
            v = f'"{v}"'
        l.append(f'{new_line} {k}={v}')
    print_kwargs = ','.join(l)
    logger.info(f'rgb=core.resize.{kernel}(clip,{print_kwargs})')

    #if interlaced flagged, height has to be reduced to half
    if field_based and 'height' in zimg_kwargs.keys():
        zimg_kwargs['height'] = zimg_kwargs['height']//2
        
    #zimg conversion
    try:
        rgb = getattr(core.resize, kernel)(clip, **zimg_kwargs)
    except Exception as e:
        return ERROR_OUT(clip, e)
   
    '''but frame was not actually requested so requesting a frame can still throw an error'''
    try:
        rgb.get_frame(0)
    except vs.Error as e:
        return ERROR_OUT(clip, e)
            
    if field_based:
        rgb = rgb.std.DoubleWeave()[::2]
        logger.info(f'rgb=rgb.std.DoubleWeave()[::2]')
    rgb = write_props(rgb, isError=0)
    
    return rgb

class Resize:
    '''
    Vapoursynth clip to rgb clip only.
    
    It is a wrapper for toRGB() where an kernel attribute is used instead of a kernel argument option, same like in vapoursynth.
    Vapoursynth clip to rgb clip only.
    The only positional argument is a clip, then only kwargs can follow. Logs all it does and there is same syntax as in vapoursynth, example:

    Usage example:
    
    import viewfunc
    rgb = viewfunc.resize.Bicubic(clip, format=vs.RGB24, dither_type='error_diffusion)
    log = viewfunc.log_string.getvalue()
    if viewfunc.read_prop(rgb, 'isError')
       raise ValueError(f'rgb conversion failed!\n{log}')
    '''
    def __getattribute__(self, kernel):
        def resize_wrapper(clip, **zimg_kwargs):                 
            if kernel not in KERNELS:
                raise AttributeError(f'wrong resize attribute, allowed attributes:\n{KERNELS}')            
            if not isinstance(clip, vs.VideoNode):
                raise ValueError(f'For resize.{kernel}(clip, **kwargs) ,first argument must be a clip')           
            return toRGB(kernel, clip, **zimg_kwargs)
        return resize_wrapper    
resize = Resize()


def auto_stack_clips(clip:          vs.VideoNode,
                     clip1:         Optional[vs.VideoNode] = None,
                     clip2:         Optional[vs.VideoNode] = None,
                     clip3:         Optional[vs.VideoNode] = None,
                     horizontal:    Optional[bool] = True,
                     size_multiple: Optional[float] = 0.5,
                     show_text:     Optional[bool]= True,
                     text_scale:    Optional[int] = 1,
                     **kwargs) -> vs.VideoNode:
    '''
    -> A convenient function to stack clips.
    -> Clips are stacked into one video, where one clip dimension is set by size_multiple float.
         Example: if size_multiple=0.5, each stacked clip will have half size of original clip size
    -> YUV or RGB clips only.
    -> Inteligently converts formats and resizes clips appropriately matching source clip, so clips can be stacked.
         if source clip (first argument) is YUV, output is YUV444 with source clip bitdepth
         if source clip (first argument) is RGB, output is same RGB format as well
    -> It can automatically print a text into video for a particular clip,
       if show_text=True and it finds "text" prop in clip. Then it prints "text" prop content into video.
       text_scale argument sets size for text. For example color_analyzer.py can set those texts for clips.
  
    Examples:
    auto_stack_clips(clip,clip1,clip2,clip3)    auto_stack_clips(clip,clip1,clip2)       auto_stack_clips(clip,clip1)   auto_stack_clips(clip)
    +------+------+                             +------+------+                          +------+------+                +------+
    | clip | clip1|                             | clip | clip1|                          | clip | clip1|              w | clip |
    +------+------+                             +------+------+                          +------+------+                +------+
    | clip2| clip3|                             | clip2|      |                                                            h 
    +------+------+                             +------+------+

    same but also horizontal=False:
    +------+------+                             +------+------+                          +------+                       +------+
    | clip | clip2|                             | clip | clip2|                          | clip |                       | clip |
    +------+------+                             +------+------+                          +------+                       +------+
    | clip1| clip3|                             | clip1|      |                          | clip1|
    +------+------+                             +------+------+                          +------+
    '''
    if clip.format.color_family not in [vs.YUV, vs.RGB]:
         raise ValueError('Source clip is not YUV or RGB')
        
    if [clip1,clip2,clip3]==[None,None,None]:
        return clip

    #size for clips that will be stacked, example: if size_multiple=0.5, then w will be half of clip.width
    w, h = clip.width//(1/size_multiple), clip.height//(1/size_multiple)
##    even = lambda v: v if v%2==0 else v+1
##    w, h = even(w), even(h)

    if clip.format.color_family == vs.YUV:
        #get YUV444 format id with clips bitdepth
        depth = clip.format.bits_per_sample
        sample_type = vs.INTEGER if clip.format.sample_type == vs.INTEGER else vs.FLOAT
        if isAPI4: YUV444_ = core.query_video_format(vs.YUV, sample_type, depth, 0, 0).id
        else:      YUV444_ = core.register_format(vs.YUV, sample_type, depth, 0, 0).id

    #convert clips
    clips = []
    for c in [clip, clip1, clip2, clip3]:
        if c is None:
            continue
        if clip.format.color_family == vs.YUV:
            if c.format.color_family == vs.YUV:
                c = c.resize.Bicubic(w, h, format=YUV444_)
            elif c.format.color_family == vs.RGB:
                c = c.resize.Bicubic(w, h, format=YUV444_, matrix=get_matrix(c)[0], range=get_zimg_range(c)[0])
            else:
                raise ValueError('Optional clip for auto_stack_clips() must be YUV or RGB only')

        else: #clip is RGB
            if c.format.color_family == vs.YUV:
                 c = toRGB('Bicubic', c, width=w, height=h, format=clip.format.id)
                 if read_prop(c.get_frame(0), 'isError'):
                     log = log_string.getvalue()
                     c = c.text.Text(f'rgb conversion failed:\n{log}')
            elif c.format.color_family == vs.RGB:
                c = c.resize.Bicubic(w, h)
            else:
                raise ValueError('Optional clip for auto_stack_clips() must be YUV or RGB only')
        clips.append(c)
  
    if show_text:
        def print_text(n, clip, f, scale):
            if 'text' in f.props: return clip.text.Text(f.props['text'], alignment=7, scale=scale)
            else:                 return clip        
        clips = [c.std.FrameEval(functools.partial(print_text, clip=c, scale=text_scale ), prop_src=c) for c in clips]
    if  len(clips) == 1:  return clips[0]
    if horizontal: S1, S2 = core.std.StackHorizontal, core.std.StackVertical
    else:          S1, S2 = core.std.StackVertical,   core.std.StackHorizontal

    if len(clips)   == 2: return S1([clips[0], clips[1]])
    elif len(clips) == 3: return S2([S1([clips[0], clips[1]]), S1([clips[2], clips[0].std.BlankClip()])])
    else:                 return S2([S1([clips[0], clips[1]]), S1([clips[2], clips[3]])])


def get_pixel_value(f, position):
    '''
    Returns a tuple with three values (ints or floats).
    Input: vs.VideoFrame and tuple with two int values (int, int) for pixel position.
    usage:      
    import viewfunc
    #(x,y) coordinates are (100,200)
    r,g,b = viewfunc.get_pixel_value(RGB_clip.get_frame(25645), (100,200))
    y,u,v = viewfunc.get_pixel_value(YUV_clip.get_frame(25645), (100,200))
    #or
    f = gray_clip.get_frame(2687)
    y, _, _ = viewfunc.get_pixel_value(f, (100,200))  # or:  y=viewfunc.get_pixel_value(f, (100,200))[0]
    '''
    if not isinstance(f, vs.VideoFrame):                    
            raise TypeError(f'[get_pixel_values]: first argument needs to be vs.VideoFrame type')
    if not isinstance(position, (tuple, list)):
        raise TypeError(f'[get_pixel_values]: Second argument needs to be a pixel position argument, it must be a tuple with integers, example: (245,405)')

    x,y = position
    p0, p1, p2 = (None, None, None)
    if isAPI4: planes =[f[i] for i in range(f.format.num_planes)]
    else:      planes =[f.get_read_array(i) for i in range(f.format.num_planes)]  

    if f.format.name == 'CompatYUY2':
        try:
            pack = planes[0][y,x]
            p0 = pack & 0xFF
            p1 = (pack >> 8) & 0xFF
            if x % 2 == 0:
                pack = planes[0][y,x+1]
                p2 = (pack >> 8) & 0xFF
            else:
                p2 = p1
                pack = planes[0][y,x-1]
                p1 = (pack >> 8) & 0xFF                                
        except:
            p0, p1, p2 = (None, None, None)

    elif f.format.name == 'CompatBGR32':
        try:
            pack = planes[0][f.height-1 - y, x]
            p2 = pack & 0xFF
            p1 = (pack >> 8) & 0xFF
            p0 = (pack >> 16) & 0xFF
        except:
            p0, p1, p2 = (None, None, None)

    else:
        try:    p0 = planes[0][y,x]
        except: p0 = None
        ys = y >> f.format.subsampling_h
        xs = x >> f.format.subsampling_w
        try:    p1 = planes[1][ys,xs]
        except: p1 = None
        try:    p2 = planes[2][ys,xs]
        except: p2 = None

    return p0,p1,p2 

def get_frame_props(f):
    '''
    Returns a pretty formatted string of vs.VideoFrame props with added detail from PROP dictionary (if available)
    usage:
    import viewfunc
    text = viewfunc.get_frame_props(clip.get_frame(0)) #frame 0
    '''
    if not isinstance(f, vs.VideoFrame):                    
        raise TypeError(f'[get_frame_props]: argument needs to be vs.VideoFrame type')   
    info = []
    for k, v in dict(f.props).items():
        if isinstance(v, bytes): v = v.decode()            
        try:             end = f'={PROPS[k][v]}\n'
        except KeyError: end = '\n'
        info.append(f'{k: <20}{v}' + end)
    return ''.join(info)


def freeRAM():
    ''' 
    Returns free RAM integer in MB or None if it fails .
    It is cross os function. 
    
    First it uses non standard cross platform library psutil.
    If module is not installed, it falls back to Windows, then Linux ways to get free RAM
    for Mac it needs psutil though:  pip install psutil
    '''

    avail = None
    
    '''cross platform library psutil'''     
    try:
        import psutil
    except ImportError:
        pass    
    else:
        mem = psutil.virtual_memory()
        avail = int(mem.available/1024/1024)
        if avail and isinstance(avail, int):
            return avail
    
    '''windows fallback'''
    try:
        proc = os.popen('wmic.exe OS get FreePhysicalMemory')
        l = proc.readlines()
        proc.close()
    except:
        pass
    else:
        for i, item in enumerate(l):
            try:
                avail = int(l[i])
                avail = int(avail/1024)
                if avail and isinstance(avail, int):
                    return avail 
            except:
                pass
               
    '''linux fallback'''
    try:
        meminfo = dict((i.split()[0].rstrip(':'),int(i.split()[1])) for i in open('/proc/meminfo').readlines())
        avail = int(meminfo['MemAvailable']/1024)
        if avail and isinstance(avail, int):
            return avail 
    except:
        pass
                     
    '''failed to get free RAM'''
    err = "[freeRAM] Install psutil(pip3 psutil install) to get free RAM\n"
    err +="[freeRAM] psutil is needed to get free RAM on Mac" #or add some fallback code for Mac here
    try:
        log(err)
    except:
        raise Exception(err)
    return None


def limit_core_cache(core):
    '''
    Sets core.max_cache_size for less than available RAM.
    Returns a tuple (core, log).
    Usage:  
    from vapoursynth import core
    import viewfunc
    core, log = viewfunc.limit_core_cache(core)
    #print(log)
    #print(core.max_cache_size)
    '''               
    log = []
    available = None
    vs_cache = core.max_cache_size
    log.append(f'vapoursynth cache is set to: {vs_cache}MB')
    available_RAM = freeRAM()
    if available_RAM is not None:
        log.append(f'free RAM: {available_RAM}MB')
        deduct = 0
        if available_RAM < 200:
            deduct = 50                   
            log.append('almost no RAM, system likely to freeze')
        elif 200 <= available_RAM < 400:
            deduct = 120                   
            log.append('not much RAM at all, freezing likely, lagish performance')
        elif 400 <= available_RAM < 1024:
            deduct = 220
            log.append('more RAM would give better performance')
        elif 1024 <= available_RAM < 1536:
            deduct = 280                       
        else:
            deduct = 350
        new_cache =  max(50, available_RAM - deduct)          
        if new_cache < vs_cache:
            log.append(f'setting Vapoursynth cache to: {new_cache}MB')
            core.max_cache_size = new_cache
    else:
        log.append('\nWARNING, failed to get available free RAM,')
        log.append('         Vapoursynth cache was not limited if needed,')
    return core, '\n'.join(log)


def color_bars(width=1280, height=720, format=vs.YUV420P8):
    '''Returns color bar clip. Needs colorbars.dll,  https://github.com/ifb/vapoursynth-colorbars/releases '''
    try:
        c = core.colorbars.ColorBars(format=vs.YUV444P10)
    except vs.Error:
        return default_error_rgb_clip()
    c = write_props(c, _FieldBased=0)
    c = core.std.Convolution(c,mode="h",matrix=[1,2,4,2,1])
    c = core.resize.Point(clip=c, width=width, height=height, format=format)
    return core.std.AssumeFPS(clip=c, fpsnum=24, fpsden=1)
        
def error_img(w=1280, h=720):
    '''
    outputs is black numpy array image, with two red crossed lines
    retuns: (h, w, 3) np.uint8 numpy image with two red crossing lines
    '''
    if not IS_NUMPY:  raise ImportError('[viewfunc] error_img() needs numpy and opencv modules to be installed')
    if not IS_OPENCV: raise ImportError('[viewfunc] error_img() needs opencv module to be installed')   
    img = np.zeros((h, w, 3), np.uint8)
    tloustka = 1 if w < 1921 else 2
    cv2.line(img, (0, 0), (w, h), (0,0,130), tloustka, cv2.LINE_AA)
    cv2.line(img, (0, h), (w, 0), (0,0,130), tloustka, cv2.LINE_AA)
    return img

def rgb_clip_from_numpy(img, length=1):
    '''
    output is 8bit black rgb vs.VideoNode with two red crossed lines
    input: is some numpy (h, w, 3), np.uint8 image
    '''
    if not IS_NUMPY: raise ImportError('[viewfunc] error_img() needs numpy module to be installed')    
    def get_vsFrame(n, f, img):
        vsFrame = f.copy()
        if isAPI4: [np.copyto(np.asarray(vsFrame[i]), img[:, :, i]) for i in [2,1,0]]
        else:      [np.copyto(np.asarray(vsFrame.get_write_array(i)), img[:, :, i]) for i in [2,1,0]]
        return vsFrame
    placeholder = core.std.BlankClip(width=img.shape[1], height=img.shape[0], format=vs.RGB24, length=length)
    clip = core.std.ModifyFrame(placeholder, placeholder, lambda n,f: get_vsFrame(n,f,img=img))
    rgb = core.std.ShufflePlanes(clip, planes=[2, 1, 0], colorfamily=vs.RGB)
    return rgb

def default_error_rgb_clip(width=1280, height=720, format=vs.RGB24, length=1):
    if IS_NUMPY and IS_OPENCV and format==vs.RGB24:
        #black rgb will have two red cross lines
        return rgb_clip_from_numpy(error_img(width, height), length=length)
    return core.std.BlankClip(width=width, height=height, format=format, length=length)


def clip_info(clip):
    if not isinstance(clip, vs.VideoNode):
        return ''
    '''returns text with basic vapoursynth clip data'''
    if not clip.fps.numerator:
        duration = int(clip.num_frames * 25)
    else:    
        duration = int(clip.num_frames * clip.fps.denominator / clip.fps.numerator)
    info = '{0}x{1}  {2}({3}/{4})fps   {5}   {6}  {7}frames'.format(
      clip.width,
      clip.height,
      round(clip.fps.numerator/clip.fps.denominator, 3),
      clip.fps.numerator,
      clip.fps.denominator,
      clip.format.name if clip.format is not None else 'dynamic format',
      sec2time(duration),
      clip.num_frames)
    return info

def sec2time(sec):
    ''' Convert seconds to 'D days, HH:MM:SS.FFF' '''
    m, s = divmod(sec, 60)
    h, m = divmod(m, 60)
    d, h = divmod(h, 24)
    pattern = '%%02d:%%02d:%%0%d.%df' % (6, 3)
    if d == 0:
        return pattern % (h, m, s)
    return ('%d days, ' + pattern) % (d, h, m, s)

def get_user_app_dir(app_name):
    '''cross os func, it returns a directory where apps can store their files, typicly for particular operating system'''
    table = {'win32':  'AppData/Roaming',
             'linux':  '.local/share',
             'darwin': 'Library/Application Support'}
    try:              datadir = os.path.join( os.path.expanduser('~'), table[sys.platform])
    except KeyError:  datadir = os.getcwd()
    user_app_dir = os.path.join(datadir, app_name)
    try:
        os.makedirs(user_app_dir)
    except FileExistsError:
        pass
    return user_app_dir

def load_vapoursynth_dlls(core, abs_dlls_dir):
    log = ''
    if not platform.architecture()[0] == '64bit':
            log += "Only 64bit vapoursynth supported, vapoursynth dll's could not be loaded."
            return False, log
    try:        
        basenames = [f for f in os.listdir(abs_dlls_dir) if  f.lower().endswith('.dll')]
    except FileNotFoundError:
        basenames = []
        
    count=0
    exception = False
    for basename in basenames:
        try:    
            core.std.LoadPlugin(os.path.join(abs_dlls_dir, basename))
            count +=1
            log += 'loaded: ' + basename + '\n'
        except Exception as e:
            exception = True
            log += f"{str(e)}\n"
        
    log += f"Loaded {count} vapoursynth dll's manually from {abs_dlls_dir}\n"
    if not count:
        log += f'There are no dll\'s in "{abs_dlls_dir}",'\
               f'or vapoursynth auto loaded dll\'s'
    return False if (exception or count==0) else True, log
